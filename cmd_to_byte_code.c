/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cmd_to_byte_code.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yjohns <yjohns@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2019/12/25 02:56:18 by yjohns            #+#    #+#             */
/*   Updated: 2020/02/15 04:51:42 by yjohns           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "asm.h"

/*
 * Каждая функция описывается своим кодом и аргументами.
 * Код принимается в качестве одного байта типа чар
 * Для каждой функции существует своя подфункция, которая принимает
 * аргументы и находит полное битовое представление команды
 * и её размер в байтах.
 *
 * Так как при передаче аргументов в общую функцию неизвестно,
 * сколько должно быть аргументов и какая у них разрядность,
 * мы передаем в массиве int значения всех трех. Считается,
 * что все метки уже были заменены на числовые значения
 *
 * Главная функция find_cmd на данный момент является войд,
 * но при необходимости может возвращать код возникающей ошибки,
 * что можно использовать при валидации
 *
 */

unsigned char	get_argcode_sum(char op_0, char op_1, char op_2)
{
	unsigned char	sum_code;

	sum_code = 0;
	sum_code |= (unsigned char)(op_0 << 6);
	sum_code |= (unsigned char)(op_1 << 4);
	sum_code |= (unsigned char)(op_2 << 2);
	return (sum_code);
}

void        cmd_arg_to_byte(t_file *file, int num, int dir_s)
{
	int 	i;
	unsigned int	arg_s;

	i = 0;
	arg_s = 0;
	while (i < num)
	{
		if (FT->op[i][0] == 1)
			arg_s = 8;
		else if (FT->op[i][0] == 2 || FT->op[i][0] == 4)
			arg_s = dir_s * 8;
		else if (FT->op[i][0] == 3 || FT->op[i][0] == 5)
			arg_s = 16;
		while (arg_s != 0)
		{
			file->exec_str[file->exec_size++] |= FT->op[i][1] >> (arg_s - 8);
			arg_s -= 8;
		}
		i++;
	}
}

/*
 * Шаблон функций, обрабатывающих аргументы команды:
 * токен, количество аргументов, размер типа T_DIR
 *
 * Все функции записывают найденную последовательность байт непосредственно в строку.
 * Индекс массива для записи определяется текущим значением exec_size
 *
 * Если у нас не существует FT->op[1], значит в команде только один аргумент и
 * нам не нужно находить сумму кодов типа аргумента
 */

void		is_label_in_list(t_file *file, int size, char **args)
{
	int		i;

	i = 0;
	while (args[i])
	{
		FL = file->start_label;
		while(FL)
		{
			if (!ft_strcmp(*args, FL->name))
			{
				if (FT->op[0][0] == 4 || FT->op[0][0] == 5)
					FT->op[0][1] = FL->offset - size;
				else if (FT->op[1][0] == 4 || FT->op[1][0] == 5)
					FT->op[1][1] = FL->offset - size;
				break ;
			}
			FL = FL->next;
		}
		if (!FL)
			exit(1);
		i++;
	}
}

void		cmd_to_byte_code(t_file *file)
{
	unsigned char	sum_code;
	int 			start_size;

	start_size = (int)file->exec_size;
	file->token = file->start_token;
	while(FT)
	{
		/*
		 * is_label_in_list - проверка на то, что метка, данная в аргументах, имеет место куда ссылаться,
		 * то есть элемент в списке t_label(все метки, стоящие перед командами) с таким же именем. Если всё хорошо,
		 * то записываем в качестве значения переменной расстояние FL->offset - size,
		 * где оффсет - расстояние от начала исполняемого кода до метки в байтах, а size - параметр функции
		 * который содержит расстояние от начала исп. кода до команды. Учитывается не фактическое расстояние,
		 * а расстояние в байт-коде, поэтому указателем на текущую команду будет номер байта после предыдущей команды.
		 *
		 * прим: в одной команде в качестве параметра может быть максимум две текстовые метки одновременно
		 */
		if (FT->label)
			is_label_in_list(file, (int) file->exec_size, ft_strsplit(FT->label->name, ' '));
		file->exec_str[file->exec_size++] |= FT->code;
		/*
		 * Шаблон функций, обрабатывающих аргументы команды:
		 * токен, количество аргументов, размер типа T_DIR
		 *
		 * Все функции записывают найденную последовательность байт непосредственно в строку.
		 * Индекс массива для записи определяется текущим значением exec_size
		 *
		 * Если у нас не существует FT->op[1], значит в команде только один аргумент и
		 * нам не нужно находить сумму кодов типа аргумента
		 */
		if (FT->op[1])
		{
			sum_code = get_argcode_sum(FT->op[0][0], FT->op[1][0], FT->op[2][0]);
			file->exec_str[file->exec_size++] |= sum_code;
		}
		cmd_arg_to_byte(file, op_tab[FT->code - 1].arguments,
						(op_tab[FT->code - 1].code5 == 1 ? 2 : 4));
		FT = FT->next;
	}
}
